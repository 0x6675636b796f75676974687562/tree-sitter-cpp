=========================================
Namespace definitions
=========================================

namespace std {

int x;

}  // namespace std

---

(translation_unit
  (namespace_definition
    (identifier)
    (declaration_list
      (declaration (type_name) (variable_name))))
  (comment))

=========================================
Using declarations
=========================================

using a;
using ::b;
using c::d;
using ::e::f::g;
using h = i::j;
using namespace std;

---

(translation_unit
  (using_declaration (identifier))
  (using_declaration (scoped_identifier (identifier)))
  (using_declaration (scoped_identifier (identifier) (identifier)))
  (using_declaration
    (scoped_identifier
      (scoped_identifier (scoped_identifier (identifier)) (identifier))
      (identifier)))
  (alias_declaration
    (identifier)
    (type_descriptor (scoped_identifier (identifier) (identifier))))
  (using_declaration (identifier)))

=========================================
Reference declarations
=========================================

int main() {
  T &x = y<T &>();
}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement
      (declaration
        (type_name)
        (init_declarator
          (reference_declarator (variable_name))
          (call_expression
            (template_function_expansion
              (template_name)
              (type_descriptor (type_name) (abstract_reference_declarator)))
            (argument_list)))))))

=========================================
R-value reference declarations
=========================================

int main(T &&);

int main(T &&t) {
  const U &&u = v;
}

---

(translation_unit
  (declaration
    (type_name)
    (function_declarator
      (variable_name)
      (parameter_list (parameter_declaration (type_name) (abstract_reference_declarator)))))
  (function_definition
    (type_name)
    (function_declarator
      (variable_name)
      (parameter_list (parameter_declaration (type_name) (reference_declarator (variable_name)))))
    (compound_statement
      (declaration
        (type_qualifier)
        (type_name)
        (init_declarator (reference_declarator (variable_name)) (variable_name))))))

=========================================
Inline method definitions
=========================================

struct S {
  int f;

  S() : f(0) {}

 private:
  int getF() const { return f; }
};

---

(translation_unit
  (struct_specifier (type_name) (field_declaration_list
    (field_declaration (type_name) (field_name))
    (function_definition
      (function_declarator (variable_name) (parameter_list))
      (field_initializer_list (field_initializer (identifier) (argument_list (number_literal))))
      (compound_statement))
    (access_specifier)
    (function_definition
      (type_name)
      (function_declarator (field_name) (parameter_list) (type_qualifier))
      (compound_statement (return_statement (variable_name)))))))

=========================================
Constructor and destructor declarations
=========================================

class C {
  void *data_;

 public:
  C();
  C(int, float);
  ~C();
};

---

(translation_unit
  (class_specifier (type_name) (field_declaration_list
    (field_declaration (type_name) (pointer_declarator (field_name)))
    (access_specifier)
    (declaration (function_declarator (variable_name) (parameter_list)))
    (declaration (function_declarator (variable_name) (parameter_list
      (parameter_declaration (type_name))
      (parameter_declaration (type_name)))))
    (declaration (function_declarator (destructor_name (variable_name)) (parameter_list))))))

=========================================
Classes with inheritance
=========================================

class A : public B {
};

class C : C::D, public E {
};

---

(translation_unit
  (class_specifier
    (type_name)
    (base_class_clause (type_name))
    (field_declaration_list))
  (class_specifier
    (type_name)
    (base_class_clause (scoped_identifier (identifier) (identifier)) (type_name))
    (field_declaration_list)))

=========================================
Friend declarations
=========================================

struct C {
  friend class D;
  friend int f(C &);
};

---

(translation_unit
  (struct_specifier (type_name) (field_declaration_list
    (friend_declaration (class_specifier (type_name)))
    (friend_declaration (declaration (type_name) (function_declarator
      (variable_name)
      (parameter_list (parameter_declaration (type_name) (abstract_reference_declarator)))))))))

=========================================
Function parameters with default values
=========================================

int foo(bool x = 5) {}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator
      (variable_name)
      (parameter_list
        (parameter_declaration (type_name) (init_declarator (variable_name) (number_literal)))))
    (compound_statement)))

=========================================
Operator overload declarations
=========================================

ostream &operator<<(ostream &, const A &a);

bool A::operator!=(const A &other) const;

---

(translation_unit
  (declaration
    (type_name)
    (reference_declarator
      (function_declarator
        (operator_name)
        (parameter_list
          (parameter_declaration (type_name) (abstract_reference_declarator))
          (parameter_declaration (type_qualifier) (type_name) (reference_declarator (variable_name)))))))
  (declaration
    (type_name)
    (function_declarator
      (scoped_identifier (identifier) (operator_name))
      (parameter_list
        (parameter_declaration (type_qualifier) (type_name) (reference_declarator (variable_name))))
      (type_qualifier))))

=========================================
Template declarations
=========================================

template <typename T>
void foo(T &t);

template <typename T, int u>
int bar(T &t) { return u; }

template <typename T>
class Foo {};

---

(translation_unit
  (template_declaration
    (template_parameter_list
      (type_parameter_declaration (type_name)))
    (declaration
      (type_name)
      (function_declarator
        (variable_name)
        (parameter_list
          (parameter_declaration (type_name) (reference_declarator (variable_name)))))))
  (template_declaration
    (template_parameter_list
      (type_parameter_declaration (type_name))
      (parameter_declaration (type_name) (variable_name)))
    (function_definition
      (type_name)
      (function_declarator
        (variable_name)
        (parameter_list (parameter_declaration (type_name) (reference_declarator (variable_name)))))
      (compound_statement (return_statement (variable_name)))))
  (template_declaration
    (template_parameter_list
      (type_parameter_declaration (type_name)))
    (class_specifier (type_name) (field_declaration_list))))

=========================================
Template specializations
=========================================

template <>
void foo<T>(T &t);

template <>
struct foo::bar<T> {};

---

(translation_unit
  (template_declaration
    (template_parameter_list)
    (declaration
      (type_name)
      (function_declarator
        (template_function_expansion (template_name) (type_descriptor (type_name)))
        (parameter_list
          (parameter_declaration (type_name) (reference_declarator (variable_name)))))))
  (template_declaration
    (template_parameter_list)
    (struct_specifier
      (template_type_expansion (scoped_identifier (identifier) (identifier)) (type_descriptor (type_name)))
      (field_declaration_list))))

==========================================
Declarations with braced initializer lists
==========================================

A foo{1, 2};

---

(translation_unit
  (declaration
    (type_name)
    (init_declarator (variable_name) (initializer_list (number_literal) (number_literal)))))

===========================================
Empty function bodies
===========================================

int main() {}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement)))

==========================================
Explicit template instantiations
==========================================

template A<int, bool>::A(char *, size_t);

---

(translation_unit
  (template_instantiation
    (function_declarator
      (scoped_identifier
        (template_type_expansion
          (template_name)
          (type_descriptor (type_name))
          (type_descriptor (type_name)))
        (identifier))
      (parameter_list
        (parameter_declaration (type_name) (abstract_pointer_declarator))
        (parameter_declaration (type_name))))))
