================================================
Scoped function calls
================================================

int main() {
  abc::def("hello", "world");
}

---

(translation_unit (function_definition
  (type_name)
  (function_declarator (variable_name) (parameter_list))
  (compound_statement
    (expression_statement (call_expression
      (scoped_identifier (identifier) (identifier))
      (argument_list
        (string_literal)
        (string_literal)))))))

=================================================
Compound literals without parentheses
=================================================

T x = T{0};
U<V> y = U<V>{0};

---

(translation_unit
  (declaration
    (type_name)
    (init_declarator
      (variable_name)
      (compound_literal_expression
        (type_name)
        (initializer_list (number_literal)))))
  (declaration
    (template_type_expansion (template_name) (type_descriptor (type_name)))
    (init_declarator
      (variable_name)
      (compound_literal_expression
        (template_type_expansion (template_name) (type_descriptor (type_name)))
        (initializer_list (number_literal))))))

=================================================
Explicit destructor calls
=================================================

int main() {
  foo.~Foo();
  bar->~Bar();
}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement
      (expression_statement (call_expression
        (field_expression (variable_name) (destructor_name (variable_name)))
        (argument_list)))
      (expression_statement (call_expression
        (field_expression (variable_name) (destructor_name (variable_name)))
        (argument_list))))))

=================================================
New and Delete expressions
=================================================

int main() {
  auto a = new T();
  auto b = new U::V{};
  auto c = new (&d) T();
  auto c = new T[5][3]();
  delete a;
  ::delete[] c;
}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement
      (declaration
        (auto)
        (init_declarator
          (variable_name)
          (new_expression (type_name) (argument_list))))
      (declaration
        (auto)
        (init_declarator
          (variable_name)
          (new_expression (scoped_identifier (identifier) (identifier)) (initializer_list))))
      (declaration
        (auto)
        (init_declarator
          (variable_name)
          (new_expression
            (parenthesized_expression (pointer_expression (variable_name)))
            (type_name)
            (argument_list))))
      (declaration
        (auto)
        (init_declarator
          (variable_name)
          (new_expression
            (type_name)
            (new_declarator (number_literal) (new_declarator (number_literal)))
            (argument_list))))
      (expression_statement (delete_expression (variable_name)))
      (expression_statement (delete_expression (variable_name))))))

====================================================
Initializer lists as arguments
====================================================

int main() {
  pairs.push_back({true, false});
}

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement
      (expression_statement (call_expression
        (field_expression (variable_name) (field_name))
        (argument_list (initializer_list (variable_name) (variable_name))))))))

====================================================
Lambda expressions
====================================================

auto f = [&](int x) -> bool {
  return true;
};

---

(translation_unit
  (declaration
    (auto)
    (init_declarator
      (variable_name)
      (lambda_expression
        (lambda_capture_specifier (lambda_default_capture))
        (abstract_function_declarator
          (parameter_list (parameter_declaration (type_name) (variable_name)))
          (trailing_return_type (type_name)))
        (compound_statement (return_statement (variable_name)))))))

====================================================
Nested template calls
====================================================

class A {
  B<C::D<E, F>>::G field;

  H<I<J>> method() {
    K::L<M<N>> variable1 = K::L<M<N>>{};
  }
};

---

(translation_unit
  (class_specifier (type_name) (field_declaration_list
    (field_declaration
      (scoped_identifier
        (template_type_expansion
          (template_name)
          (type_descriptor (template_type_expansion
            (scoped_identifier (identifier) (identifier))
            (type_descriptor (type_name)) (type_descriptor (type_name)))))
        (identifier))
      (field_name))
    (function_definition
      (template_type_expansion
        (template_name)
        (type_descriptor
          (template_type_expansion
            (template_name)
            (type_descriptor (type_name)))))
      (function_declarator (field_name) (parameter_list))
      (compound_statement
        (declaration
          (template_type_expansion
            (scoped_identifier (identifier) (identifier))
            (type_descriptor
              (template_type_expansion (template_name) (type_descriptor (type_name)))))
          (init_declarator
            (variable_name)
            (compound_literal_expression
              (template_type_expansion
                (scoped_identifier (identifier) (identifier))
                (type_descriptor
                  (template_type_expansion
                    (template_name)
                    (type_descriptor (type_name)))))
              (initializer_list)))))))))

====================================================
Comma expressions at the start of blocks
====================================================

int main() { a(), b(); }

---

(translation_unit
  (function_definition
    (type_name)
    (function_declarator (variable_name) (parameter_list))
    (compound_statement
      (expression_statement (comma_expression
        (call_expression (variable_name) (argument_list))
        (call_expression (variable_name) (argument_list)))))))
